#!/usr/bin/env python3
"""
deytefiles - Main control script for dotfiles repository management.

This is the entry point that delegates to modular command implementations.
"""

import sys
import argparse
from pathlib import Path

# Add dotfiles lib to Python path
SCRIPT_DIR = Path(__file__).parent.resolve()
DOTFILES_LIB = SCRIPT_DIR.parent / 'share' / 'dotfiles'
if str(DOTFILES_LIB) not in sys.path:
    sys.path.insert(0, str(DOTFILES_LIB))

from cli.commands import BootstrapCommand, SyncCommand


def create_parser():
    """Create and configure argument parser."""
    parser = argparse.ArgumentParser(
        description="Deytefiles - Dotfiles repository management tool",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    subparsers = parser.add_subparsers(
        dest='command',
        help='Available commands'
    )
    
    # Bootstrap command
    bootstrap_parser = subparsers.add_parser(
        'bootstrap',
        help='Run bootstrap process to set up dotfiles'
    )
    bootstrap_parser.add_argument(
        '-q', '--quiet',
        action='store_true',
        help='Suppress notifications'
    )
    
    # Sync command
    sync_parser = subparsers.add_parser(
        'sync',
        help='Sync dotfiles repository with remote'
    )
    sync_parser.add_argument(
        '-m', '--message',
        help='Custom commit message',
        default=None
    )
    sync_parser.add_argument(
        '-f', '--force',
        action='store_true',
        help='Force push with --force-with-lease'
    )
    sync_parser.add_argument(
        '-q', '--quiet',
        action='store_true',
        help='Suppress notifications'
    )
    
    return parser


def main():
    """Main entry point for the deytefiles script."""
    parser = create_parser()
    args = parser.parse_args()
    
    # Show help if no command provided
    if not args.command:
        parser.print_help()
        return 1
    
    # Command mapping
    commands = {
        'bootstrap': BootstrapCommand,
        'sync': SyncCommand,
    }
    
    # Get and execute command
    command_class = commands.get(args.command)
    if command_class:
        command = command_class(args)
        return command.execute()
    
    # Unknown command (shouldn't happen due to argparse)
    parser.print_help()
    return 1


if __name__ == '__main__':
    sys.exit(main())
